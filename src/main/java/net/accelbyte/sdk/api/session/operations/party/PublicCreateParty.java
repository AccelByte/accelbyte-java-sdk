/*
 * Copyright (c) 2022 AccelByte Inc. All Rights Reserved
 * This is licensed software from AccelByte Inc, for limitations
 * and restrictions contact your company contract manager.
 *
 * Code generated. DO NOT EDIT.
 */

package net.accelbyte.sdk.api.session.operations.party;

import java.io.*;
import java.util.*;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import net.accelbyte.sdk.api.session.models.*;
import net.accelbyte.sdk.core.HttpResponseException;
import net.accelbyte.sdk.core.Operation;
import net.accelbyte.sdk.core.util.Helper;

/**
 * publicCreateParty
 *
 * <p>A join code will be autogenerated if the party is joinable.
 *
 * <p>A user can be in 1 party at a time, therefore the requester will be removed from their
 * previous party (if any) and automatically added/joined into this newly created party as a leader.
 *
 * <p>Session configuration name is optional. Default configuration name if empty: { "name":
 * "default", "type": "NONE", "joinability": "OPEN", "minPlayers": 1, "maxPlayers": 8,
 * "inviteTimeout": 60, "inactiveTimeout": 60, "textChat": false } When session configuration "name"
 * is provided, we will refer to the template if these fields are empty: - textChat - minPlayers -
 * maxPlayers - inviteTimeout - inactiveTimeout - type - joinability - configurationName -
 * attributes
 *
 * <p>Supported platforms: 1. STEAM 2. PSN 3. XBOX
 *
 * <p>Reserved attributes key: 1. preference: used to store preference of the leader and it is
 * non-replaceable to keep the initial behavior of the session regardless the leader changes. 2.
 * NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation
 * system UI.
 *
 * <p>Session has 2 fields for user status: "status" and "statusV2". The "status" is there for
 * backward-compatibility, therefore we encourage to just rely on "statusV2" for the more updated
 * statuses.
 *
 * <p>User statuses: 1. INVITED: by default, to join a session (except session with OPEN joinability
 * or if session configuration has "autoJoin" sets to True) a user will receive an invite. The
 * invitee will have the chance to respond within "inviteTimeout" which you can configure through
 * session configuration. 2. TIMEOUT: when a user is invited to a session, they will receive an
 * invite. Unless "disableResendInvite" sets to True in the session configuration, the user will
 * also receive invite reminder every 30s until they respond to the invite. 3. REJECTED: when a user
 * rejects an invite. To rejoin an INVITE_ONLY session, they will need to be re-invited and accept
 * the invite. 4. JOINED: there are few ways of a user to join a session, by invite, direct join
 * (depends on session joinability) or join by code. upon invite, once a user accepts an invite,
 * their status will be changed to JOINED. 5. LEFT: user can leave a session. in case of party, a
 * user can only be in 1 party at a time. therefore when they decide to create or join another
 * party, they will be automatically removed from their initial party and their status will be
 * changed to LEFT. 6. KICKED: only party leader can kick a member. 7. DISCONNECTED: if user still
 * have reserved seat in the session and they disconnect lobby websocket, their status in the
 * session will be changed to DISCONNECTED and field "members.previousStatus" of that user will
 * contains the initial status before they disconnect lobby websocket. the user will be given chance
 * to reconnect within "inactiveTimeout" which you can configure through session configuration. 8.
 * CONNECTED: when a user reconnect their lobby websocket, their status will change from
 * DISCONNECTED to CONNECTED, only if they previously JOINED session. if they were on INVITED state
 * before the disconnect happened, the user's status will return back to INVITED after they
 * reconnect. 9. DROPPED: when "inactiveTimeout" is due and user never re-establish their websocket
 * connection, we will drop them from the session. 10. TERMINATED: only applies to game session. If
 * a game session (match) is ended, DS will end/delete the session and we will mark all remaining
 * users' status to be TERMINATED. 11. CANCELLED: when a session joinability changes to CLOSED, any
 * remaining invites will be canceled.
 *
 * <p>User is considered as active if they're present in the session, which their status either
 * CONNECTED or JOINED. User has a reserved seat in the session if their status either INVITED,
 * JOINED, CONNECTED, DISCONNECTED. When user's' status change to other than these mentioned
 * statuses, we will release the seat for other players to occupy.
 *
 * <p>Managing the relation between session and lobby websocket connection: - Session relies on
 * lobby to consider player's connection health to our backend. therefore a disruption to lobby
 * websocket will be reflected in the user's status in all of their session(s). - If user still have
 * a reserved seat in the session and they disconnect lobby websocket, their status in session(s)
 * will be changed to DISCONNECTED and field "members.previousStatus" of that user will contains the
 * initial status before they disconnect lobby websocket. This "members.previousStatus" used to
 * track user's previous status before they disconnect websocket, since we still reserve a seat for
 * them, therefore this field will be empty again after they websocket. - If the disconnected user
 * is the leader of the session they're disconnected from, we will wait until
 * "leaderElectionGracePeriod" is due, to promote the next oldest member as the new leader of the
 * session. You can configure "leaderElectionGracePeriod" through session configuration. - The user
 * will be given chance to reconnect within "inactiveTimeout" which you can configure through
 * session configuration. If until "inactiveTimeout" is due and the user doesn't reconnect their
 * websocket, they will be removed from session and their status will change to DROPPED. If the
 * dropped user was the leader of the session, we will promote the next oldest member as leader. -
 * By default, we will update user's status to what it was before disconnect, when the user
 * reconnects lobby websocket, unless "manualRejoin" sets to True in the session configuration. When
 * "manualRejoin" is enabled, after lobby websocket reconnect, the game client will need to manually
 * invoke join session again to rejoin the session. - If the user was on INVITED state before the
 * disconnect happened, the user's status will return back to INVITED after they reconnect.
 */
@Getter
@Setter
public class PublicCreateParty extends Operation {
  /** generated field's value */
  private String path = "/session/v1/public/namespaces/{namespace}/party";

  private String method = "POST";
  private List<String> consumes = Arrays.asList("application/json");
  private List<String> produces = Arrays.asList("application/json");
  private String locationQuery = null;

  /** fields as input parameter */
  private String namespace;

  private ApimodelsCreatePartyRequest body;

  /**
   * @param namespace required
   * @param body required
   */
  @Builder
  // @deprecated 2022-08-29 - All args constructor may cause problems. Use builder instead.
  @Deprecated
  public PublicCreateParty(String namespace, ApimodelsCreatePartyRequest body) {
    this.namespace = namespace;
    this.body = body;

    securities.add("Bearer");
  }

  @Override
  public Map<String, String> getPathParams() {
    Map<String, String> pathParams = new HashMap<>();
    if (this.namespace != null) {
      pathParams.put("namespace", this.namespace);
    }
    return pathParams;
  }

  @Override
  public ApimodelsCreatePartyRequest getBodyParams() {
    return this.body;
  }

  @Override
  public boolean isValid() {
    if (this.namespace == null) {
      return false;
    }
    return true;
  }

  public ApimodelsPartySessionResponse parseResponse(
      int code, String contentType, InputStream payload) throws HttpResponseException, IOException {
    if (code != 200) {
      final String json = Helper.convertInputStreamToString(payload);
      throw new HttpResponseException(code, json);
    }
    final String json = Helper.convertInputStreamToString(payload);
    return new ApimodelsPartySessionResponse().createFromJson(json);
  }
}
